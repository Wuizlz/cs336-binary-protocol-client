<!doctype html>

<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>CS 33600 - Homework 3</title>
  <meta name="description" content="CS 33600 Homework 3">
  <meta name="author" content="Roger L. Kraft">
  <link rel="stylesheet" href="http://cs.pnw.edu/~rlkraft/roger-v2.css">
</head>

<body>
<!--
<header>
  <a href="http://cs.pnw.edu/~rlkraft/" title="Roger L. Kraft">Roger L. Kraft</a>
</header>
 -->
<nav>
  <ul class="nav-list">
    <li><a href="../cs33600.html">CS 33600</a></li>
    <li><a href="../syllabus.html">Syllabus</a></li>
    <li><a href="../class.html">Lectures and Readings</a></li>
    <li><a href="../homework.html">Homework Assignments</a></li>
  </ul>
  <ul class="nav-list">
    <li><a href="http://cs.pnw.edu/~rlkraft/roger.html">Roger Kraft</a></li>
    <li><a href="https://pnw.edu/computer-science/">Computer Science Department</a></li>
    <li><a href="https://pnw.edu/engineering/">School of Engineering</a></li>
    <li><a href="https://pnw.edu/college-of-engineering-sciences/">College of Engineering & Sciences</a></li>
    <li><a href="https://pnw.edu/">Purdue University Northwest</a></li>
  </ul>
</nav>

<section id="Content">
<h1>
Programming Assignment 3<br>
CS 33600<br>
Network Programming<br>
Spring, 2026
</h1>

<p>
This assignment makes use of the files contained in this <a href="hw3.zip">zip file</a>.
This assignment is due Tuesday, March 3.
</p>

<p>
This assignment is based on the code examples from the <code>data_formats</code> sub folder of <a href="../for-class/streams_and_processes.zip">streams_and_processes.zip</a> and the explanations in <a href="../for-class/readmes/Readme_data_formats/">Readme_data_formats.md</a>.
</p>

<p>
This assignment simulates a server process communicating with a client process using a "binary message protocol". In the zip file there is a file <code>Server.java</code> that implements the server. Your assignment is to implement the client program, <code>Client.java</code>.
</p>

<p>
The server program "sends" messages to the client program by writing the messages to its standard output stream. The client program should "receive" messages by reading them from its standard input stream. The command line
</p>
<pre>
   &gt; java Server 10 | java Client
</pre>
<p>
uses a pipe to simulate the communication channel from the server to the client. The server's command-line argument 10 tells the server to send 10 messages to the client.
</p>

<p>
Here is a description of the message protocol used by this client/server pair. Each message begins with a single byte that is a "message header". There are three kinds of messages, a "numeric message", a "text message", and an "end-of-transmision" message. After a message header will be the "body" of the message (except for the end-of-transmission message which has no message body; it consists of just the message header byte).
</p>

<p>
The message header for the end-of-transmission message is <code>0x80</code> (in hexadecimal). The meaning of this message header is that there are no more messages and the server will close its output stream, and the client should close its input stream.
</p>

<p>
The message header for a "text message" has its most significant bit set to <code>1</code> and its seven least significant bits set to an integer value between 1 and 127. The meaning of this message header is that it will be followed by the given number of printable <a href="https://ss64.com/ascii.html">ASCII</a> characters (hexadecimal <code>0x20</code> through <code>0x7E</code>), which the client should read.
</p>

<p>
The message header for the "numeric message" has its most significant bit set to <code>0</code>. The remaining seven bits are a <a href="https://en.wikipedia.org/wiki/Bit_field">bit field</a> with the following meaning. A <code>0</code> bit tells the client to expect a <code>float</code> value to be sent to it by the server. A <code>1</code> bit tells the client to expect a <code>long</code> value to be sent to it by the server. The client should read seven bit values from the message header, starting from the least significant bit. So, for example, if the message header in hexadecimal is <code>0x39</code> (or binary <code>0b00111001</code>), then the client should expect to receive, in order, one long, then two floats, then three longs, followed by one float.
</p>

<p>
The eight bytes of a long are sent by the server in <a href="https://www.google.com/search?q=little+endian">little-endian byte order</a>. That means that the server sends the least significant byte of a long first, followed by the second-least significant byte, etc. for all eight bytes of the long (for example, see <a href="https://images.squarespace-cdn.com/content/v1/549dcda5e4b0a47d0ae1db1e/1490746414666-EM74IA60AFM16OEH9G22/image-asset.png">this</a> or <a href="https://open4tech.com/wp-content/uploads/2020/05/little_endian_vs_big_endian.png">this</a> picture). Java stores <code>long</code> values in <a href="https://www.google.com/search?q=big+endian">big-endian byte order</a>, so the byte order used by the server program is not the same as Java's byte order.
</p>

<p>
The four bytes of an float are sent by the server in "weird-endian" byte order. For the purpose of this assignment, the weird-endian byte order means that the server will first send the second-least significant byte of the float, followed by the least significant byte, followed by the most significant byte, followed by the float's second-most significant byte. Java stores <code>float</code> values in big-endian byte order.
</p>

<p>
Immediately after the server sends the last byte from the body of a message, the server will send the message header byte for the next message.
</p>

<p>
In order to work with the bytes of a <code>long</code> in little-endian order, or the bytes of an <code>float</code> in weird-endian order, you need to use Java's <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html">ByteBuffer</a> class. The <code>ByteBufer</code> class has methods that let you convert a <code>long</code> or a <code>float</code> into an array of bytes (in big-endian byte order). And there are methods that let you convert an array of four bytes into a <code>float</code> value or an array of eight bytes into a <code>long</code> value (again, in big-endian byte order).
</p>

<p>
The <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html#putLong(long)">putLong()</a> and <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html#putFloat(float)">putFloat()</a> methods let you convert a <code>long</code> value or a <code>float</code> value into its appropriate byte values in a <code>ByteBuffer</code> object. Then the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html#array()">array()</a> method constructs a <code>byte[]</code> object from the <code>ByteBuffer</code> object. For example, the following line of code creates an array of four bytes holding the bytes that represent the <code>float</code> value <code>123456789.0</code>.
</p>
<pre>
    byte[] b = ByteBuffer.allocate(Float.BYTES).putFloat(123456789.0F).array();
</pre>
<p>
The following line of code creates an array of eight bytes holding the bytes that represent the <code>long</code> value <code>1234567890987654321</code>.
</p>
<pre>
    byte[] b = ByteBuffer.allocate(Long.BYTES).putLong(1234567890987654321L).array();
</pre>

<p>
For the other direction, from byte array to <code>long</code> or <code>float</code> value, the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html#wrap(byte%5B%5D)">wrap()</a> method constructs a <code>ByteBuffer</code> object from a <code>byte[]</code> object, and the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html#getLong()">getLong()</a> and <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html#getFloat()">getFloat()</a> methods convert an appropriately sized <code>ByteBuffer</code> into an <code>long</code> or <code>float</code> value. For example, the following line of code returns the <code>float</code> value of the four bytes in the given <code>byte[]</code> object.
</p>
<pre>
    float n = ByteBuffer.wrap(new byte[]{4, 3, 2, 1}).getFloat();
</pre>

<p>
The following line of code returns the <code>long</code> value of the eight bytes in the given <code>byte[]</code> object.
</p>
<pre>
    long n = ByteBuffer.wrap(new byte[]{8, 7, 6, 5, 4, 3, 2, 1}).getLong();
</pre>

<p>
When you have a <code>long</code> value stored in a <code>byte[]</code> array, then you can move the bytes around in the array to convert from big-endian to little-endian (or vice versa). When you have a <code>float</code> value stored in a <code>byte[]</code> array, then you can move the bytes around in the array to convert from big-endian to weird-endian (or vice versa). The server will be converting from big-endian to either little-endian or weird-endian (look at the <code>Server.java</code> source code). The client program will be converting from either little-endian or weird-endian to big-endian.
</p>

<p>
You can experiment with the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/ByteBuffer.html">ByteBuffer</a> API using the following program in the Java Visualizer.
</p>
<ul>
   <li><a href="https://cscircles.cemc.uwaterloo.ca/java_visualize/#code=import+java.nio.ByteBuffer%3B%0Aimport+java.util.Arrays%3B%0A%0Apublic+class+TestByteBuffer%0A%7B%0A+++public+static+void+main(String%5B%5D+args)%0A+++%7B%0A++++++//+float+to+byte%5B%5D%0A++++++byte%5B%5D+b1+%3D+ByteBuffer.allocate(Float.BYTES).putFloat(8765.432F).array()%3B%0A++++++System.out.println(Arrays.toString(+b1+))%3B%0A%0A++++++//+long+to+byte%5B%5D%0A++++++byte%5B%5D+b2+%3D+ByteBuffer.allocate(Long.BYTES).putLong(987654321).array()%3B%0A++++++System.out.println(Arrays.toString(+b2+))%3B%0A%0A++++++//+byte%5B%5D+to+float%0A++++++float+f+%3D+ByteBuffer.wrap(new+byte%5B%5D%7B70,+64,+-26,+-74%7D).getFloat()%3B%0A++++++System.out.println(+f+)%3B%0A%0A++++++//+byte%5B%5D+to+long%0A++++++byte%5B%5D+b3+%3D+%7B1,+55,+105,+35,+-6,+-8,+11,+78%7D%3B%0A++++++long+n+%3D+ByteBuffer.wrap(+b3+).getLong()%3B%0A++++++System.out.println(+n+)%3B%0A+++%7D%0A%7D&mode=edit">TestByteBuffer.java</a></li>
</ul>

<p>
Also, look at the program <code>Server.java</code> in the zip file for more example code that uses <code>ByteBuffer</code> and <code>byte[]</code> objects.
</p>

<p>
Write a program <code>Client.java</code> that implements the receiving end of the above protocol. Besides implementing the above protocol, your <code>Client.java</code> program should do a few other things. The client should keep track of how many bytes it is receiving from the server. After receiving an end-of-transmision message, the client should print out its count of the total number of bytes it received from the server. If the client should detect an end-of-file condition before receiving an end-of-transmission message, the client should print an error message that includes the number of bytes it has received so far from the server. The client should also print to standard output the contents of each text message and each numeric message.
</p>

<p>
Your client program should NOT read all of its input data into some array or list. That is a very bad strategy, for several reasons. Your program does not know how much data it will receive, so it does not know how much memory is needed to store all the input data (it may be more that what is available to you on the current computer). Your program will not produce any output until all the input data has been received, so your program will appear "dead" and unresponsive. If your program is in the middle of a data pipeline, then your program becomes a bottle neck for the pipeline, blocking all the data that needs to pass through the pipeline. Your program (and almost any filter program) should process its input data as soon as it receives it, and output the processed data right away. Your client program should print out each ASCII character as soon as it receives it. Your client program should print out each <code>long</code> value and each <code>float</code> value as soon as it has decoded it.
</p>

<p>
Your client program should read its standard input stream one byte at a time (using the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/InputStream.html#read()">read()</a> method from <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/InputStream.html">InputStream</a>). After <b>every</b> <code>read</code>, your program should check for end-of-file (the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/InputStream.html#read()">read()</a> method returns <code>-1</code> to denote the end-of-file condition). Your program should not assume that it gets reliable data from the server. The data from the server may unexpectedly end at any point in the input stream. Your program should not crash on an unexpected end-of-file. When I test your client program, I will randomly terminate its input stream in the middle of a message. If the input stream is closed in the middle of a text message, you should have already printed the part of the text message you received, so your client can terminate. If the input stream is closed in the middle of a numeric message, you should have already printed out the complete numbers you have received. A partial <code>long</code> or <code>float</code> that is interrupted by a closed stream can be discarded, and your client can terminate. When your client terminates because of a unexpected end-of-file, your client should report that it detected an unexpected end-of-file and your client should print out its count of the total number of bytes it received from the server.
</p>

<p>
To help you debug your <code>Client.java</code> program, each time the server program is run it logs all the messages it sends to the client into a text file called <code>log_file.txt</code>. The log file contains very verbose versions of the messages sent to the client. The log file shows the message headers in binary number notation, it shows the long and float numbers in both decimal and hexadecimal formats (in the transmitted byte order), and it tells you the length of the text messages in decimal format.
</p>

<p>
Each time you run the server program, it creates a random set of messages. If you want to test your client program with a repeatable set of messages, run the server one time and capture its binary output in a file. This command captures five messages.
</p>
<pre>
   &gt; java Server 5 > data
</pre>
<p>
Then run your client as many times as you want with the <code>data</code> file as its input.
</p>
<pre>
   &gt; java Client < data
</pre>
<p>
When you save a data file from the server, be sure to keep a copy of the server's <code>log_file.txt</code> along with the data file. The log file will help you determine if your client's output is correct.
</p>

<p>
In the zip file there is an example data file, its accompanying log file, and the client's results from reading that data. You can use that data as a test case for your client program.
</p>

<p>
If you want to directly look at the contents of a data file created by <code>Server.java</code>, then you need to use a program designed for inspecting binary files. These kinds of programs are usually called "hex editors". There is a very useful, online hex editor called <a href="https://docs.werwolv.net/imhex">ImHex</a>. You can just drag-and-drop a binary file onto its web page and it will open the file in its hex view.
</p>
<ul>
<li><a href="https://web.imhex.werwolv.net/">ImHex online</a></li>
</ul>

<p>
You can test that your client program handles an unexpected end-of-file by taking a saved <code>data</code> file and deleting some data from the end of the file. When you feed that truncated <code>data</code> file into your client program, your program should report that it detected an unexpected end-of-file and your program should report the correct number of bytes in the truncated data file.
</p>

<p>
In the zip file for this assignment you will find an <a href="https://docs.oracle.com/javase/tutorial/deployment/jar/run.html">executable jar file</a> demo program called <code>client_demo.jar</code> that you can use to demo this assignment. You can pipe the output from <code>Server</code> into the demo program with this command-line (which sends five messages to the demo program).
</p>
<pre>
     &gt; java Server 5 | java -jar client_demo.jar
</pre>
<p>
Or you can run the demo program on a saved data file with this command-line.
</p>
<pre>
     &gt; java -jar client_demo.jar < data
</pre>
<p>
Your version of <code>Client.java</code> should behave <em>exactly</em> like the demo version.
</p>

<p>
DO NOT run the server program, the demo program, or your version of the client program, in Microsoft's PowerShell. PowerShell does not like binary streams, and these programs will not run correctly.
</p>

<p>
If you would like to look at "real world" examples of binary data protocols, here is the binary format for the <a href="https://datatracker.ietf.org/doc/html/rfc791#section-3.1">Internet Protocol Datagram Header</a> and the binary format for the <a href="https://datatracker.ietf.org/doc/html/rfc793#section-3.1">Transmission Control Protocol Header</a>. Notice how they both use a mixture of 1-bit, 4-bit, 8-bit, 16-bit, and 32-bit fields. Here is a third, simpler example, the binary format for the <a href="https://datatracker.ietf.org/doc/html/rfc768">User Datagram Header Format</a>. Here is a more complex example, the binary format of the <a href="https://datatracker.ietf.org/doc/html/rfc5905#page-19">Network Time Protocol Packet Header</a>
</p>

<p>
<a href="http://cs.pnw.edu/~rlkraft/cs33600/handin.html">Turn in</a> a zip file called <code>CS336Hw3Surname.zip</code> (where <code>Surname</code> is your last name) containing your version of <code>Client.java</code>.
</p>

<p>
This assignment is due Tuesday, March 3.
</p>

</section>

<footer>
  <script>
    document.write('<small><small><i>Last modified on ' + document.lastModified + '.</i></small></small>');
  </script>
  <br>
  <a href="mailto:rlkraft@pnw.edu"><small><small><i>compliments and criticisms</i></small></small></a>
</footer>

</body>
</html>
